(defpackage :group
  (:use :cl)
  (:export
   :set-class
   :set-union
   :set-intersect
   :difference
   :+mod
   :*mod))
(in-package :group)

(defclass set-class ()
  ((elements
   :initarg :set
   :initform '()
   :accessor elements))
  (:documentation "An unordered set."))

(defgeneric set-union (a b)
  (:documentation "Performs a union on two containers"))
(defgeneric set-intersect (a b)
  (:documentation "Performs an intersect on two containers"))
(defgeneric difference (a b)
  (:documentation "Gets the difference of container a from b"))

(defmethod set-union ((a set-class) (b set-class))
  (make-instance 'set-class :set (union (elements a) (elements b))))
(defmethod set-intersect ((a set-class) (b set-class))
  (make-instance 'set-class :set (intersection (elements a) (elements b))))
(defmethod difference ((a set-class) (b set-class))
  (make-instance 'set-class :set (set-difference (elements a) (elements b))))

(defclass semi-group (set-class)
  ((operation
    :initarg :operation
    :initform (error "Group must be given an operation.")
    :accessor operation))
  (:documentation "Semi-group algebraic structure."))

(defun make-semigroup (set operation)
  (make-instance 'semi-group :set set :operation operation))

(defmethod initialize-instance :after ((sg semi-group) &key)
  (unless (functionp (operation sg))
    (error "Algebraic structure operation is not a function.")))

(defclass group (semi-group)
  ((identity
    :reader group-identity))
  (:documentation "Group algebraic structure"))

(define-condition bad-group-axioms (error)
  ((set-elements :initarg :elements :reader elements)
   (set-operation :initarg :operation :reader operation)
   (axiom :initarg :axiom :reader axiom)))
(defun make-group (set operation)
  (restart-case (make-instance 'group :set set :operation operation)
    (make-semi-group () :report "Make semigroup instead of a group"
		     (make-semigroup set operation))))

(defgeneric get-identity (structure &optional operation)
  (:documentation "Gets the identity element in a structure under a binary operation."))
(defmethod get-identity ((s set-class) &optional operation)
  (loop for id in (elements s) thereis
       (when (loop for conj in (elements s)
		always (and (equal (funcall operation conj id) conj)
			    (equal (funcall operation id conj) conj)))
	 id)))
(defmethod get-identity ((sg semi-group) &optional (operation (operation sg)))
  (call-next-method sg operation))

(defgeneric get-inverse (structure element &optional identity operation)
  (:documentation "Gets the inverse element in a structure under a binary operation"))
(defmethod get-inverse ((s set-class) element &optional (id nil id-p) operation)
  (let ((identity (if (and id-p id) id (get-identity s operation))))
    (when identity
      (loop for inv in (elements s) thereis
	   (when (and (equal identity (funcall operation inv element))
		      (equal identity (funcall operation element inv)))
	     inv)))))
(defmethod get-inverse ((sg semi-group) element &optional id (operation (operation sg)))
  (call-next-method sg element id operation))

(defgeneric closurep (structure &optional operation)
  (:documentation "Checks if a given structure is closed under an operation."))
(defgeneric identityp (structure &optional operation)
  (:documentation "Checks if a given structure has an identity under an operation."))
(defgeneric invertiblep (structure &optional id operation)
  (:documentation "Checks if a given structure has an identity and every element is invertible under an operation."))

(defmethod closurep ((s set-class) &optional operation)
  (let ((elements (elements s)))
    (loop for g in elements always
	 (loop for h in elements always (and (member (funcall operation g h) elements)
					     (member (funcall operation h g) elements))))))
(defmethod closurep ((sg semi-group) &optional (operation (operation sg)))
  (call-next-method sg operation))

(defmethod invertiblep ((s set-class) &optional id operation)
  (loop for g in (elements s) always
       (get-inverse s g id operation)))
(defmethod invertiblep ((sg semi-group) &optional id (operation (operation sg)))
  (call-next-method sg id operation))

(defmethod identityp ((s set-class) &optional operation)
  (when (get-identity s operation) t))
(defmethod identityp ((sg semi-group) &optional (operation (operation sg)))
  (call-next-method sg operation))

(defmethod initialize-instance :after ((g group) &key (skip-test nil))
  (setf (slot-value g 'identity) (get-identity g))
  (unless skip-test
    (macrolet ((do-error (axiom) `(error 'bad-group-axioms :elements (elements g) :operation (operation g) :axiom ,axiom)))
      (cond ((not (closurep g))       (do-error 'closure))
	    ((not (group-identity g)) (do-error 'identity))
	    ((not (invertiblep g))    (do-error 'inversible))))))

(defun integers (a b) (loop for i from a to b collect i))
(defun +mod (base) #'(lambda (&rest numbers) (mod (apply #'+ numbers) base)))
(defun *mod (base) #'(lambda (&rest numbers) (mod (apply #'* numbers) base)))
